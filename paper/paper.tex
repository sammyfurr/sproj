\documentclass[12pt]{article}
\usepackage{multicol}
\usepackage{cite}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[doublespacing]{setspace}
\usepackage{hyperref}
\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage}

\lstset{basicstyle=\ttfamily}
\graphicspath{{./images/}}

\author{Sammy Furr}
\title{The Development of a Collaborative Tool to Teach Debugging}
\date{\today}

\begin{document}

\begin{titlepage}
  \maketitle
\end{titlepage}

\begin{abstract}
  TODO: write an abstract
\end{abstract}

\tableofcontents
\pagebreak

\section{Introduction}
\subsection{Motivation}

Debugging is invaluable in writing and understanding code, yet it is
rarely formally taught\cite{doi:10.1080/08993400802114581}.  We
typically teach students programming structures, concepts, and
languages, but leave them to learn the tools they use to write code by
themselves.  This approach often works well---a programmer's choice of
tools is often \textit{very} personal and students figure out how to
configure an individualized workflow.  Perhaps because debuggers are
tools, students are often expected to learn them with minimal
guidance.  Unlike editors or reference guides however, effectively
using a debugger requires a set of high-level, platform agnostic,
teachable skills.  Teaching these skills is effective, and translates
into better, faster, debugging and
programming\cite{10.1145/3286960.3286970}\cite{10.1145/3361721.3361724}.

\subsubsection{The Value of Teaching Debugging}

There is an unfortunate lack of research specifically into the
efficacy of teaching debugging for computer science students, despite
a recent rise in the inclusion of debugging in ``computational
thinking'' curriculums\cite{10.1145/3361721.3361724}.  These
curriculums attempt to teach skills in computer science classes that
translate into other subject areas: the UK's computer science
curriculum considers debugging an essential ``transferable
skill''\cite{10.1145/2602484}.\par There seems to be confidence that
the problem-solving techniques used in debugging are widely
applicable, but of greater interest to computer science teachers is
whether teaching debugging directly benefits student programmers.
Michaeli and Romeike conducted a good, albeit somewhat small, study on
the efficacy of teaching a systematic debugging process to K12
students.  They found that students who have been taught a specific
debugging framework performed better in debugging tests and were more
confident in their own debugging skills\cite{10.1145/3361721.3361724}.
Their result is positive evidence towards the efficacy of teaching
debugging, though it doesn't include college or university
students.\par

As Michaeli and Romeike point out, there is a lack of research into
the value of teaching debugging in higher education.  None of the
research these authors found placed much focus on explicitly teaching
debugging.  Chmiel and Loui studied whether students who were provided
with debugging tools and frameworks performed better on tests or spent
less time on assignments than those who were
not\cite{10.1145/971300.971310}.  Though this research wasn't able to
find conclusive evidence towards better performance on tests or
assignments, it did find that students in the treatment group felt
more confident in their debugging abilities.  Unfortunately Chmiel and
Loui's study didn't involve extended explicit teaching of
debugging---use of the tools was voluntary, and variations in the
students' individual abilities made the data difficult to
evaluate.\par

Though there is a lack of higher-education research, the value of
teaching debugging is still demonstrable.  The research discussed all
finds that K-12 and college students alike commonly resort to sporadic
debugging techniques when beginning to learn.  Since this pattern of
behavior that explicitly teaching debugging corrects exists in college
as well as in K-12 students, it seems logical that the benefit of
explicitly teaching debugging to K-12 students should be realized
equally by their collegiate counterparts.\par

\subsubsection{Methods for Teaching Debugging}

Similarly to research on the value of teaching debugging, research
into how to best teach debugging is self-admittedly sparse.  Chan et
al. allow that ``in general research on how to improve debugging is
sporadic''---an observation that leads them to research a framework to
reduce the complexity of teaching
debugging\cite{10.1145/3286960.3286970}.  To organize their framework,
they split debugging knowledge into 5 categories: \textit{Domain},
\textit{System}, \textit{Procedural}, \textit{Strategic}, and
\textit{Experiential}.  They then review different debugging tools and
teaching aids---from those that involve writing code to games---and
map tools to the knowledge areas they seek to address.  After an
evaluation of a host of different tools, they claim to find a few
significant faults in current debugging teaching platforms. The
primary two which this project seeks to address are as follows:

\begin{enumerate}
\item A lack of back-tracing ability/coverage.
\item A lack of tools addressing system knowledge (an understanding of
  the program to be debugged).
\end{enumerate}

\subsubsection{The Value of Collaborative Programming}

TODO: find some basic research that backs up the claim that
collaborative/pair programming is worthwhile.

\subsubsection{Tools that Enable Collaborative Programming}

TODO: write about glitch, repl.it, etc.

\subsubsection{Collaborative Programming and Teaching Debugging}

Debuggers exist at an intersection of tools and skills similar to
programming languages themselves. By becoming familiar with a specific
debugger, students learn techniques and paradigms necessary to use all
debuggers effectively.
\pagebreak

\subsection{Project Components}

\begin{figure}[h!]

  \includegraphics[scale=.8]{overall_system}
  \centering
  \caption{Overview of the Collaborative Debugger}
  \label{debugger:overview}
\end{figure}

The next sections give an overview of the various tools used to create
the collaborative debugger.  The debugger consists of:

\begin{enumerate}
\item A frontend web app built using React (\ref{react}) that presents a debugging
  interface to the end user.
\item A distributed backend managed by Kubernetes (\ref{k8s}), split into three parts:
  \begin{enumerate}
  \item A pod for each debugging instance which runs the rr debugger
    (\ref{rr}).  These communicate directly with users through
    WebSocket server pods. (\ref{socketio}).
  \item Pods running a frontend server written in Node which works in
    tandem with an API server created using Flask (\ref{flask/node}).
    The API server manages creation and destruction of debug sessions,
    as well as authentication.
  \item A MongoDB database.
  \end{enumerate}
\end{enumerate}

\subsubsection{Kubernetes}\label{k8s}

Kubernetes is the defacto standard in container orchestration
software.  It provides a layer of abstraction on top of normal
containers, like those created by Docker.  By bundling one or more
closely linked containers into a ``pod'', Kubernetes is able to manage
deployment and re-deployment of applications running inside
containers.  It is trivial to create new pods, or to create multiple
pods running the same application as needed within a Kubernetes
cluster \cite{k8s}.  The speed at which even relatively large pods can be created
and the inherent security provided by containerization drove the
decision to create a new pod on the fly for each debugging instance in
the collaborative debugger.
\par

Kubernetes also provides services to facilitate load balancing, manage
storage volumes, and contain secrets.  The abstraction provided by
these features, in tandem with the ease of Kubernetes deployment on a
managed Kubernetes service\cite{do_managed_k8s} greatly accelerated
development.

\subsubsection{Mozilla's rr}\label{rr}

\paragraph{Overview}

rr is ``a lightweight tool for recording, replaying and debugging
execution of applications''\cite{rr-repo}. rr allows a programmer to
record the execution of a program on any compatible machine and replay
the execution later.  This enhances GDB's ability to ``time-travel''
when debugging, using commands such as \lstinline{reverse-continue}
and \lstinline{reverse-stepi}\cite{gdbman} to step backwards and
forwards through a program's execution.  Through a novel encapsulation
of the execution space, rr is able to deterministically record and
replay the execution of syscalls and other process behavior that
differs run-to-run.  This is invaluable when trying to debug behavior
that is not entirely dependent on the code being debugged.  A typical
workflow in rr consists of recording an inexplicable error, replaying
execution to find the area in which the error occurs, and then
narrowing in on the bug not by re-running the entire program, but by
progressing back and forth through execution in the problem area.
\par

rr is an ideal tool for teaching debugging because it allows
instructors to record execution of a program and design a debugging
example with the knowledge that normally non-deterministic events will
be repeatable, and that any input they provide to the program will be
exactly replicated.  With the collaborative debugger, teachers can
record a program's execution and design a debugging lesson which
students can work on together.  The repeatablity of rr means that
students can focus on debugging, and teachers can create as specific
examples as they please.

\paragraph{Limitations}

In comparison to solutions like PANDA\cite{10.1145/2843859.2843867}
that rely on capturing the entire state of of a virtual machine to
replay execution, rr records and replays faster, produces far smaller
files, and doesn't force execution inside of a
VM.\cite{DBLP:journals/corr/OCallahanJFHNP17} The tradeoff for these
benefits are two major system limitations: rr is only compatible with
the Linux kernel, and it's deterministic recording and replay relies
on a feature that is only found on modern \textit{Intel} x86 CPUs.
These limitations influenced the development of this project as a
webapp similar to existing tools for collaborative programming.
\par

Luckily, the speed and size benefits of rr lend themselves well to
non-local execution.  In conjunction with Kubernetes, it takes a few
seconds to create a new container running rr and connect to web
clients.

\subsubsection{pygdbmi}



\subsubsection{Socket.IO}\label{socketio}

To speed communication, the collaborative debugger uses WebSockets to
directly connect web clients and the pods running rr.  Socket.IO is a
library that extends WebSockets.  It provides backup incase a
WebSocket connection cannot be established, enables automatic
reconnection and disconnection detection, and adds support for
namespaces \cite{socketio}.  The collaborative debugger uses the
standard Javascript implementation of Socket.IO on the client side.
Messages are passed through a server to individual debugging pods,
both of which use the Python implementation of Socket.IO,
python-socket.io \cite{python_socketio}.

\subsubsection{Flask and Node}\label{flask/node}

\subsubsection{React and Xterm.js}\label{react}

\subsection{Project Overview}

TODO: a brief overview linking aspects of the project to background
research discussed above.

\section{Design}

TODO: the big piece of writing, detailing components of the project,
the system as a whole, and motivations for design choices.

\section{Next Steps}

TODO: write about additional/necessary unimplemented features (ATM
this is looking like auth stuff, unless OAuth2 proves to be less of a
pain in the ass then when I've used it before in Javascript.  Maybe
some of the vis stuff as well, though I'd really like to get the
basics done here.)  Write about desire to actually do research and see
whether the tool helps students learn debugging.

\pagebreak
\bibliographystyle{acm}
\bibliography{sprojbib}{}
\end{document}
